# Why use xpcc?

<center>
![](images/rca_angulatus.jpg)
</center>

xpcc is tailored for the harsh requirements of the [Eurobot competition][eurobot],
where our robots need to run reliably and completely autonomously for the games
duration. Furthermore, our robots started off running on AVRs, so xpcc also
needs to be very efficient with its resources to be able to support these tiny
microcontrollers.
All in all, this means we need a really robust and safe foundation to build all
our code upon.

This foundation is xpcc.
It runs very reliably and efficiently on AVR as well as ARM Cortex-M cores.
Here are the reasons why.

## Data-driven design

The most unique thing about xpcc is how we generate our hardware abstraction
layer (HAL) drivers.
We have assembled the unique meta data of all of our targets, such as number
and type of peripherals, pins, memories and interrupts.
This way we know which devices are similar to each other even before opening the
datasheet, and we can make informed decisions about what HAL drivers an entire
*family* of devices requires, rather than going through this cumbersome process
for each device individually.

This dramatically reduces duplicated code, required a lot less porting effort
and leads to much higher device coverage of our HAL drivers.
By combining the specific device meta data with our driver templates, we
collect the similarities and differences between device families in one common
place, which makes it so much easier to reason about them.

This extract from the [STM32F407 device file][stm32f407] shows
several types of peripheral drivers as well as additional information like
instances and pin alternate functions:
```xml
...
<driver type="adc" name="stm32" instances="1,2,3"/>
<driver type="clock" name="stm32"/>
<driver type="i2c" name="stm32" instances="1,2,3"/>
<driver type="uart" name="stm32" instances="1,2,3,4,5,6"/>
<driver type="gpio" name="stm32">
  <gpio port="A" id="0">
    <af id="1" peripheral="Timer2" name="Channel1"/>
    <af id="8" peripheral="Uart4" name="Tx" type="out"/>
    <af peripheral="Adc1" name="Channel0" type="analog"/>
  </gpio>
  ...
```

This information is then passed to our HAL drivers, which use code generation
tools, specifically the [Jinja2 template engine][jinja2], to generate the
appropriate C++ code structures for the specified target:
<markdeep-diagram>
                                    .------------.          .------.
                               .-->| ADC Template |    .-->| GpioA0 |
                              |     '------------'    |     '------'
 .------.      .-----------.  |     .-------------.   |     .------.
| Target +--->| Device File +-+--->| GPIO Template +--+--->| GpioA1 |
 '------'      '-----------'  |     '-------------'   |     '------'
                              |     .------------.    |     .------.
                              +--->| I2C Template +   +--->| GpioA2 |
                              |     '------------'    |     '------'
                              :                       :
</markdeep-diagram>
This treasure trove of information is available for [every AVR and STM32
device][device_files] we support and gives us a high confidence
in the quality of our HAL ports.


## Usable & fast C++

xpcc's APIs are kept simple and fast by splitting up functionality into
separate, small, static functions, which implement the same behavior on all
platforms.
Furthermore, with our code generation capabilities, we can hide the crazy
implementation details of the hardware without compromising on performance.

For example, on different AVRs, simple things like enabling the internal PullUp resistor,
dealing with external interrupts or even just toggling a pin is done quite dissimilarly.
Yet, using static inlined functions we can call GPIO functions at [*ludicrous speed*][ludicrous],
all without using even a single byte of static RAM:
```cpp
using Led = GpioOutputB1;   // generated by GPIO HAL driver using meta-data
Led::setOutput();           // sets the pin to output on any platform
Led::set();                 // literally 1 instruction on AVR
Led::toggle();              // PORTA ^= 0x02;  or  PINA = 0x02;  if available

using Button = GpioInputA0;                 // All pins always behave the same
Button::setInput(Gpio::InputType::PullUp);  // PORTA |= 0x01;  or  PUEA |= 0x01;
bool state = Button::read();                // (PINA & 0x01)  or
Button::setInputTrigger(Gpio::InputTrigger::RisingEdge);  // don't panic!
Button::enableExternalInterrupt();          // something, something, EIMSK
Button::acknowledgeExternalInterruptFlag(); // don't worry, we will do it!
```

[ludicrous]: https://www.youtube.com/watch?v=ygE01sOhzz0
[device_files]: https://github.com/roboterclubaachen/xpcc/tree/develop/src/xpcc/architecture/platform/devices
[jinja2]: http://jinja.pocoo.org
[stm32f407]: https://github.com/roboterclubaachen/xpcc/blob/develop/src/xpcc/architecture/platform/devices/stm32/stm32f405_407_415_417-i_o_r_v_z-e_g.xml
[eurobot]: http://www.eurobot.org/
